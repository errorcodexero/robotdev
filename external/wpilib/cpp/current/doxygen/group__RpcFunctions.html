<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>WPILibC++: Remote Procedure Call Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WPILibC++
   &#160;<span id="projectnumber">unspecified</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__RpcFunctions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Remote Procedure Call Functions</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5b9ab2c7ec2ecfa65bd8e38a3e2058cc"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga5b9ab2c7ec2ecfa65bd8e38a3e2058cc">NT_RpcCallback</a>) (void *data, const struct <a class="el" href="structNT__RpcAnswer.html">NT_RpcAnswer</a> *call)</td></tr>
<tr class="memdesc:ga5b9ab2c7ec2ecfa65bd8e38a3e2058cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remote Procedure Call (RPC) callback function.  <a href="#ga5b9ab2c7ec2ecfa65bd8e38a3e2058cc">More...</a><br /></td></tr>
<tr class="separator:ga5b9ab2c7ec2ecfa65bd8e38a3e2058cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaab91bc59f5a82124864f78d80ab99784"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#gaab91bc59f5a82124864f78d80ab99784">NT_CreateRpc</a> (NT_Entry entry, const char *def, size_t def_len, void *data, <a class="el" href="group__RpcFunctions.html#ga5b9ab2c7ec2ecfa65bd8e38a3e2058cc">NT_RpcCallback</a> callback)</td></tr>
<tr class="memdesc:gaab91bc59f5a82124864f78d80ab99784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a callback-based RPC entry point.  <a href="#gaab91bc59f5a82124864f78d80ab99784">More...</a><br /></td></tr>
<tr class="separator:gaab91bc59f5a82124864f78d80ab99784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d942f44d38f62131351d570d80be6a"><td class="memItemLeft" align="right" valign="top">NT_RpcCallPoller&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#gaf8d942f44d38f62131351d570d80be6a">NT_CreateRpcCallPoller</a> (NT_Inst inst)</td></tr>
<tr class="memdesc:gaf8d942f44d38f62131351d570d80be6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a RPC call poller.  <a href="#gaf8d942f44d38f62131351d570d80be6a">More...</a><br /></td></tr>
<tr class="separator:gaf8d942f44d38f62131351d570d80be6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25915112fcb5e7adba02b130629e6093"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga25915112fcb5e7adba02b130629e6093">NT_DestroyRpcCallPoller</a> (NT_RpcCallPoller poller)</td></tr>
<tr class="memdesc:ga25915112fcb5e7adba02b130629e6093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a RPC call poller.  <a href="#ga25915112fcb5e7adba02b130629e6093">More...</a><br /></td></tr>
<tr class="separator:ga25915112fcb5e7adba02b130629e6093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga878ff7a7b432fd6c0b8eee764ee4120a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga878ff7a7b432fd6c0b8eee764ee4120a">NT_CreatePolledRpc</a> (NT_Entry entry, const char *def, size_t def_len, NT_RpcCallPoller poller)</td></tr>
<tr class="memdesc:ga878ff7a7b432fd6c0b8eee764ee4120a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a polled RPC entry point.  <a href="#ga878ff7a7b432fd6c0b8eee764ee4120a">More...</a><br /></td></tr>
<tr class="separator:ga878ff7a7b432fd6c0b8eee764ee4120a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93d69a8cf511f382e37ad80cddd48b00"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structNT__RpcAnswer.html">NT_RpcAnswer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga93d69a8cf511f382e37ad80cddd48b00">NT_PollRpc</a> (NT_RpcCallPoller poller, size_t *len)</td></tr>
<tr class="memdesc:ga93d69a8cf511f382e37ad80cddd48b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next incoming RPC call.  <a href="#ga93d69a8cf511f382e37ad80cddd48b00">More...</a><br /></td></tr>
<tr class="separator:ga93d69a8cf511f382e37ad80cddd48b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga800437b55c2ebf5b448402420bd2b2c2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structNT__RpcAnswer.html">NT_RpcAnswer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga800437b55c2ebf5b448402420bd2b2c2">NT_PollRpcTimeout</a> (NT_RpcCallPoller poller, size_t *len, double timeout, NT_Bool *timed_out)</td></tr>
<tr class="memdesc:ga800437b55c2ebf5b448402420bd2b2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next incoming RPC call.  <a href="#ga800437b55c2ebf5b448402420bd2b2c2">More...</a><br /></td></tr>
<tr class="separator:ga800437b55c2ebf5b448402420bd2b2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1a48a36a7bf37cf3f00ae26bd8dc4ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#gad1a48a36a7bf37cf3f00ae26bd8dc4ea">NT_CancelPollRpc</a> (NT_RpcCallPoller poller)</td></tr>
<tr class="memdesc:gad1a48a36a7bf37cf3f00ae26bd8dc4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a PollRpc call.  <a href="#gad1a48a36a7bf37cf3f00ae26bd8dc4ea">More...</a><br /></td></tr>
<tr class="separator:gad1a48a36a7bf37cf3f00ae26bd8dc4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6e443f5e1fce0c35d101658e0449f0b"><td class="memItemLeft" align="right" valign="top">NT_Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#gad6e443f5e1fce0c35d101658e0449f0b">NT_WaitForRpcCallQueue</a> (NT_Inst inst, double timeout)</td></tr>
<tr class="memdesc:gad6e443f5e1fce0c35d101658e0449f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the incoming RPC call queue to be empty.  <a href="#gad6e443f5e1fce0c35d101658e0449f0b">More...</a><br /></td></tr>
<tr class="separator:gad6e443f5e1fce0c35d101658e0449f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88c011f694f6d95fb12b58851c5352f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga88c011f694f6d95fb12b58851c5352f9">NT_PostRpcResponse</a> (NT_Entry entry, NT_RpcCall call, const char *result, size_t result_len)</td></tr>
<tr class="memdesc:ga88c011f694f6d95fb12b58851c5352f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post RPC response (return value) for a polled RPC.  <a href="#ga88c011f694f6d95fb12b58851c5352f9">More...</a><br /></td></tr>
<tr class="separator:ga88c011f694f6d95fb12b58851c5352f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf2b88d0559e728fad3f29768cf461d3"><td class="memItemLeft" align="right" valign="top">NT_RpcCall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#gaaf2b88d0559e728fad3f29768cf461d3">NT_CallRpc</a> (NT_Entry entry, const char *params, size_t params_len)</td></tr>
<tr class="memdesc:gaaf2b88d0559e728fad3f29768cf461d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a RPC function.  <a href="#gaaf2b88d0559e728fad3f29768cf461d3">More...</a><br /></td></tr>
<tr class="separator:gaaf2b88d0559e728fad3f29768cf461d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd97e095d6bb046d67ad8a2f1e9d5fbe"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#gacd97e095d6bb046d67ad8a2f1e9d5fbe">NT_GetRpcResult</a> (NT_Entry entry, NT_RpcCall call, size_t *result_len)</td></tr>
<tr class="memdesc:gacd97e095d6bb046d67ad8a2f1e9d5fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the result (return value) of a RPC call.  <a href="#gacd97e095d6bb046d67ad8a2f1e9d5fbe">More...</a><br /></td></tr>
<tr class="separator:gacd97e095d6bb046d67ad8a2f1e9d5fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aa1b97f51c05de47544b223552ff396"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga3aa1b97f51c05de47544b223552ff396">NT_GetRpcResultTimeout</a> (NT_Entry entry, NT_RpcCall call, size_t *result_len, double timeout, NT_Bool *timed_out)</td></tr>
<tr class="memdesc:ga3aa1b97f51c05de47544b223552ff396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the result (return value) of a RPC call.  <a href="#ga3aa1b97f51c05de47544b223552ff396">More...</a><br /></td></tr>
<tr class="separator:ga3aa1b97f51c05de47544b223552ff396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13dac0f3caf774a54c727ddb1ad20c9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga13dac0f3caf774a54c727ddb1ad20c9f">NT_CancelRpcResult</a> (NT_Entry entry, NT_RpcCall call)</td></tr>
<tr class="memdesc:ga13dac0f3caf774a54c727ddb1ad20c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore the result of a RPC call.  <a href="#ga13dac0f3caf774a54c727ddb1ad20c9f">More...</a><br /></td></tr>
<tr class="separator:ga13dac0f3caf774a54c727ddb1ad20c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83136a784573ddf15f5966e44ed841b2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga83136a784573ddf15f5966e44ed841b2">NT_PackRpcDefinition</a> (const struct <a class="el" href="structNT__RpcDefinition.html">NT_RpcDefinition</a> *def, size_t *packed_len)</td></tr>
<tr class="memdesc:ga83136a784573ddf15f5966e44ed841b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a RPC version 1 definition.  <a href="#ga83136a784573ddf15f5966e44ed841b2">More...</a><br /></td></tr>
<tr class="separator:ga83136a784573ddf15f5966e44ed841b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf32669d9df431ba49db556212f1acea3"><td class="memItemLeft" align="right" valign="top">NT_Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#gaf32669d9df431ba49db556212f1acea3">NT_UnpackRpcDefinition</a> (const char *packed, size_t packed_len, struct <a class="el" href="structNT__RpcDefinition.html">NT_RpcDefinition</a> *def)</td></tr>
<tr class="memdesc:gaf32669d9df431ba49db556212f1acea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a RPC version 1 definition.  <a href="#gaf32669d9df431ba49db556212f1acea3">More...</a><br /></td></tr>
<tr class="separator:gaf32669d9df431ba49db556212f1acea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fc74beb34e88d91d332c20c8fe27c1b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga2fc74beb34e88d91d332c20c8fe27c1b">NT_PackRpcValues</a> (const struct <a class="el" href="structNT__Value.html">NT_Value</a> **values, size_t values_len, size_t *packed_len)</td></tr>
<tr class="memdesc:ga2fc74beb34e88d91d332c20c8fe27c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack RPC values as required for RPC version 1 definition messages.  <a href="#ga2fc74beb34e88d91d332c20c8fe27c1b">More...</a><br /></td></tr>
<tr class="separator:ga2fc74beb34e88d91d332c20c8fe27c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b36d08440744e11de7f7ec810caac25"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structNT__Value.html">NT_Value</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga9b36d08440744e11de7f7ec810caac25">NT_UnpackRpcValues</a> (const char *packed, size_t packed_len, const NT_Type *types, size_t types_len)</td></tr>
<tr class="memdesc:ga9b36d08440744e11de7f7ec810caac25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack RPC values as required for RPC version 1 definition messages.  <a href="#ga9b36d08440744e11de7f7ec810caac25">More...</a><br /></td></tr>
<tr class="separator:ga9b36d08440744e11de7f7ec810caac25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03a487ed431a8f56acd11f94ece82bed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga03a487ed431a8f56acd11f94ece82bed">nt::NetworkTableInstance::WaitForRpcCallQueue</a> (double timeout)</td></tr>
<tr class="memdesc:ga03a487ed431a8f56acd11f94ece82bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the incoming RPC call queue to be empty.  <a href="#ga03a487ed431a8f56acd11f94ece82bed">More...</a><br /></td></tr>
<tr class="separator:ga03a487ed431a8f56acd11f94ece82bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5b4749e63b20f549bb321fde54a96ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#gab5b4749e63b20f549bb321fde54a96ed">nt::CreateRpc</a> (NT_Entry entry, StringRef def, std::function&lt; void(const RpcAnswer &amp;answer)&gt; callback)</td></tr>
<tr class="memdesc:gab5b4749e63b20f549bb321fde54a96ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a callback-based RPC entry point.  <a href="group__RpcFunctions.html#gab5b4749e63b20f549bb321fde54a96ed">More...</a><br /></td></tr>
<tr class="separator:gab5b4749e63b20f549bb321fde54a96ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3dbdf66358b269f7146ef9a92436d97"><td class="memItemLeft" align="right" valign="top">NT_RpcCallPoller&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#gab3dbdf66358b269f7146ef9a92436d97">nt::CreateRpcCallPoller</a> (NT_Inst inst)</td></tr>
<tr class="memdesc:gab3dbdf66358b269f7146ef9a92436d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a RPC call poller.  <a href="group__RpcFunctions.html#gab3dbdf66358b269f7146ef9a92436d97">More...</a><br /></td></tr>
<tr class="separator:gab3dbdf66358b269f7146ef9a92436d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fb66f1f44088fa6fdbb4384605f82ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga3fb66f1f44088fa6fdbb4384605f82ec">nt::DestroyRpcCallPoller</a> (NT_RpcCallPoller poller)</td></tr>
<tr class="memdesc:ga3fb66f1f44088fa6fdbb4384605f82ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a RPC call poller.  <a href="group__RpcFunctions.html#ga3fb66f1f44088fa6fdbb4384605f82ec">More...</a><br /></td></tr>
<tr class="separator:ga3fb66f1f44088fa6fdbb4384605f82ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebf497758cda4198a1e5afed7a43f31a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#gaebf497758cda4198a1e5afed7a43f31a">nt::CreatePolledRpc</a> (NT_Entry entry, StringRef def, NT_RpcCallPoller poller)</td></tr>
<tr class="memdesc:gaebf497758cda4198a1e5afed7a43f31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a polled RPC entry point.  <a href="group__RpcFunctions.html#gaebf497758cda4198a1e5afed7a43f31a">More...</a><br /></td></tr>
<tr class="separator:gaebf497758cda4198a1e5afed7a43f31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ce76c65122975d3f70083079af25d81"><td class="memItemLeft" align="right" valign="top">std::vector&lt; RpcAnswer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga0ce76c65122975d3f70083079af25d81">nt::PollRpc</a> (NT_RpcCallPoller poller)</td></tr>
<tr class="memdesc:ga0ce76c65122975d3f70083079af25d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next incoming RPC call.  <a href="group__RpcFunctions.html#ga0ce76c65122975d3f70083079af25d81">More...</a><br /></td></tr>
<tr class="separator:ga0ce76c65122975d3f70083079af25d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a85b610d17ff4d26dec5c7a971b27b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; RpcAnswer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga51a85b610d17ff4d26dec5c7a971b27b">nt::PollRpc</a> (NT_RpcCallPoller poller, double timeout, bool *timed_out)</td></tr>
<tr class="memdesc:ga51a85b610d17ff4d26dec5c7a971b27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next incoming RPC call.  <a href="group__RpcFunctions.html#ga51a85b610d17ff4d26dec5c7a971b27b">More...</a><br /></td></tr>
<tr class="separator:ga51a85b610d17ff4d26dec5c7a971b27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0654a104f64922b3810f19ac23adf4bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga0654a104f64922b3810f19ac23adf4bf">nt::CancelPollRpc</a> (NT_RpcCallPoller poller)</td></tr>
<tr class="memdesc:ga0654a104f64922b3810f19ac23adf4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a PollRpc call.  <a href="group__RpcFunctions.html#ga0654a104f64922b3810f19ac23adf4bf">More...</a><br /></td></tr>
<tr class="separator:ga0654a104f64922b3810f19ac23adf4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90bd47445b0424fefca0df54d97ede35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga90bd47445b0424fefca0df54d97ede35">nt::WaitForRpcCallQueue</a> (NT_Inst inst, double timeout)</td></tr>
<tr class="memdesc:ga90bd47445b0424fefca0df54d97ede35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the incoming RPC call queue to be empty.  <a href="group__RpcFunctions.html#ga90bd47445b0424fefca0df54d97ede35">More...</a><br /></td></tr>
<tr class="separator:ga90bd47445b0424fefca0df54d97ede35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga760a60f2ae5270ef7488419cf0ae8952"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga760a60f2ae5270ef7488419cf0ae8952">nt::PostRpcResponse</a> (NT_Entry entry, NT_RpcCall call, StringRef result)</td></tr>
<tr class="memdesc:ga760a60f2ae5270ef7488419cf0ae8952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post RPC response (return value) for a polled RPC.  <a href="group__RpcFunctions.html#ga760a60f2ae5270ef7488419cf0ae8952">More...</a><br /></td></tr>
<tr class="separator:ga760a60f2ae5270ef7488419cf0ae8952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafedd06b812cf26df940820f3e8eb7100"><td class="memItemLeft" align="right" valign="top">NT_RpcCall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#gafedd06b812cf26df940820f3e8eb7100">nt::CallRpc</a> (NT_Entry entry, StringRef params)</td></tr>
<tr class="memdesc:gafedd06b812cf26df940820f3e8eb7100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a RPC function.  <a href="group__RpcFunctions.html#gafedd06b812cf26df940820f3e8eb7100">More...</a><br /></td></tr>
<tr class="separator:gafedd06b812cf26df940820f3e8eb7100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3807de6df1143207fd6bfaa3e0ea4b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#gaf3807de6df1143207fd6bfaa3e0ea4b6">nt::GetRpcResult</a> (NT_Entry entry, NT_RpcCall call, std::string *result)</td></tr>
<tr class="memdesc:gaf3807de6df1143207fd6bfaa3e0ea4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the result (return value) of a RPC call.  <a href="group__RpcFunctions.html#gaf3807de6df1143207fd6bfaa3e0ea4b6">More...</a><br /></td></tr>
<tr class="separator:gaf3807de6df1143207fd6bfaa3e0ea4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f69ee5f8dadf1cda7daf78ceeac7183"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga5f69ee5f8dadf1cda7daf78ceeac7183">nt::GetRpcResult</a> (NT_Entry entry, NT_RpcCall call, std::string *result, double timeout, bool *timed_out)</td></tr>
<tr class="memdesc:ga5f69ee5f8dadf1cda7daf78ceeac7183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the result (return value) of a RPC call.  <a href="group__RpcFunctions.html#ga5f69ee5f8dadf1cda7daf78ceeac7183">More...</a><br /></td></tr>
<tr class="separator:ga5f69ee5f8dadf1cda7daf78ceeac7183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35e2a560e77fbe4af80585ff4a63dae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga35e2a560e77fbe4af80585ff4a63dae9">nt::CancelRpcResult</a> (NT_Entry entry, NT_RpcCall call)</td></tr>
<tr class="memdesc:ga35e2a560e77fbe4af80585ff4a63dae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore the result of a RPC call.  <a href="group__RpcFunctions.html#ga35e2a560e77fbe4af80585ff4a63dae9">More...</a><br /></td></tr>
<tr class="separator:ga35e2a560e77fbe4af80585ff4a63dae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fcd223fd9049b8c7b7ebd65645018f9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga4fcd223fd9049b8c7b7ebd65645018f9">nt::PackRpcDefinition</a> (const RpcDefinition &amp;def)</td></tr>
<tr class="memdesc:ga4fcd223fd9049b8c7b7ebd65645018f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a RPC version 1 definition.  <a href="group__RpcFunctions.html#ga4fcd223fd9049b8c7b7ebd65645018f9">More...</a><br /></td></tr>
<tr class="separator:ga4fcd223fd9049b8c7b7ebd65645018f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13953cf6a3e7992ba93a62fb9164132c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga13953cf6a3e7992ba93a62fb9164132c">nt::UnpackRpcDefinition</a> (StringRef packed, RpcDefinition *def)</td></tr>
<tr class="memdesc:ga13953cf6a3e7992ba93a62fb9164132c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a RPC version 1 definition.  <a href="group__RpcFunctions.html#ga13953cf6a3e7992ba93a62fb9164132c">More...</a><br /></td></tr>
<tr class="separator:ga13953cf6a3e7992ba93a62fb9164132c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22a9764da247362ab7978091e33b45c6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga22a9764da247362ab7978091e33b45c6">nt::PackRpcValues</a> (ArrayRef&lt; std::shared_ptr&lt; Value &gt;&gt; values)</td></tr>
<tr class="memdesc:ga22a9764da247362ab7978091e33b45c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack RPC values as required for RPC version 1 definition messages.  <a href="group__RpcFunctions.html#ga22a9764da247362ab7978091e33b45c6">More...</a><br /></td></tr>
<tr class="separator:ga22a9764da247362ab7978091e33b45c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2da3c02387c3bddcb5876dfa2c9afe34"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; Value &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RpcFunctions.html#ga2da3c02387c3bddcb5876dfa2c9afe34">nt::UnpackRpcValues</a> (StringRef packed, ArrayRef&lt; NT_Type &gt; types)</td></tr>
<tr class="memdesc:ga2da3c02387c3bddcb5876dfa2c9afe34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack RPC values as required for RPC version 1 definition messages.  <a href="group__RpcFunctions.html#ga2da3c02387c3bddcb5876dfa2c9afe34">More...</a><br /></td></tr>
<tr class="separator:ga2da3c02387c3bddcb5876dfa2c9afe34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga5b9ab2c7ec2ecfa65bd8e38a3e2058cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* NT_RpcCallback) (void *data, const struct <a class="el" href="structNT__RpcAnswer.html">NT_RpcAnswer</a> *call)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remote Procedure Call (RPC) callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>data pointer provided to <a class="el" href="group__RpcFunctions.html#gaab91bc59f5a82124864f78d80ab99784" title="Create a callback-based RPC entry point. ">NT_CreateRpc()</a> </td></tr>
    <tr><td class="paramname">call</td><td>call information Note: <a class="el" href="group__RpcFunctions.html#ga88c011f694f6d95fb12b58851c5352f9" title="Post RPC response (return value) for a polled RPC. ">NT_PostRpcResponse()</a> must be called by the callback to provide a response to the call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gafedd06b812cf26df940820f3e8eb7100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NT_RpcCall nt::CallRpc </td>
          <td>(</td>
          <td class="paramtype">NT_Entry&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a RPC function. </p>
<p>May be used on either the client or server. This function is non-blocking. Either <a class="el" href="group__RpcFunctions.html#gaf3807de6df1143207fd6bfaa3e0ea4b6" title="Get the result (return value) of a RPC call. ">GetRpcResult()</a> or <a class="el" href="group__RpcFunctions.html#ga35e2a560e77fbe4af80585ff4a63dae9" title="Ignore the result of a RPC call. ">CancelRpcResult()</a> must be called to either get or ignore the result of the call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>entry handle of RPC entry </td></tr>
    <tr><td class="paramname">params</td><td>parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RPC call handle (for use with <a class="el" href="group__RpcFunctions.html#gaf3807de6df1143207fd6bfaa3e0ea4b6" title="Get the result (return value) of a RPC call. ">GetRpcResult()</a> or <a class="el" href="group__RpcFunctions.html#ga35e2a560e77fbe4af80585ff4a63dae9" title="Ignore the result of a RPC call. ">CancelRpcResult()</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="ga0654a104f64922b3810f19ac23adf4bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nt::CancelPollRpc </td>
          <td>(</td>
          <td class="paramtype">NT_RpcCallPoller&#160;</td>
          <td class="paramname"><em>poller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a PollRpc call. </p>
<p>This wakes up a call to PollRpc for this poller and causes it to immediately return an empty array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>poller handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga35e2a560e77fbe4af80585ff4a63dae9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nt::CancelRpcResult </td>
          <td>(</td>
          <td class="paramtype">NT_Entry&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NT_RpcCall&#160;</td>
          <td class="paramname"><em>call</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ignore the result of a RPC call. </p>
<p>This function is non-blocking. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>entry handle of RPC entry </td></tr>
    <tr><td class="paramname">call</td><td>RPC call handle returned by <a class="el" href="group__RpcFunctions.html#gafedd06b812cf26df940820f3e8eb7100" title="Call a RPC function. ">CallRpc()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaebf497758cda4198a1e5afed7a43f31a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nt::CreatePolledRpc </td>
          <td>(</td>
          <td class="paramtype">NT_Entry&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NT_RpcCallPoller&#160;</td>
          <td class="paramname"><em>poller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a polled RPC entry point. </p>
<p>Only valid to use on the server. The caller is responsible for calling <a class="el" href="group__RpcFunctions.html#ga0ce76c65122975d3f70083079af25d81" title="Get the next incoming RPC call. ">PollRpc()</a> to poll for servicing incoming RPC calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>entry handle of RPC entry </td></tr>
    <tr><td class="paramname">def</td><td>RPC definition </td></tr>
    <tr><td class="paramname">poller</td><td>poller handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab5b4749e63b20f549bb321fde54a96ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nt::CreateRpc </td>
          <td>(</td>
          <td class="paramtype">NT_Entry&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="classnt_1_1RpcAnswer.html">RpcAnswer</a> &amp;answer)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a callback-based RPC entry point. </p>
<p>Only valid to use on the server. The callback function will be called when the RPC is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>entry handle of RPC entry </td></tr>
    <tr><td class="paramname">def</td><td>RPC definition </td></tr>
    <tr><td class="paramname">callback</td><td>callback function; note the callback function must call <a class="el" href="group__RpcFunctions.html#ga760a60f2ae5270ef7488419cf0ae8952" title="Post RPC response (return value) for a polled RPC. ">PostRpcResponse()</a> to provide a response to the call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab3dbdf66358b269f7146ef9a92436d97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NT_RpcCallPoller nt::CreateRpcCallPoller </td>
          <td>(</td>
          <td class="paramtype">NT_Inst&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a RPC call poller. </p>
<p>Only valid to use on the server. A poller provides a single queue of poll events. Events linked to this poller (using <a class="el" href="group__RpcFunctions.html#gaebf497758cda4198a1e5afed7a43f31a" title="Create a polled RPC entry point. ">CreatePolledRpc()</a>) will be stored in the queue and must be collected by calling <a class="el" href="group__RpcFunctions.html#ga0ce76c65122975d3f70083079af25d81" title="Get the next incoming RPC call. ">PollRpc()</a>. The returned handle must be destroyed with <a class="el" href="group__RpcFunctions.html#ga3fb66f1f44088fa6fdbb4384605f82ec" title="Destroy a RPC call poller. ">DestroyRpcCallPoller()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>instance handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>poller handle </dd></dl>

</div>
</div>
<a class="anchor" id="ga3fb66f1f44088fa6fdbb4384605f82ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nt::DestroyRpcCallPoller </td>
          <td>(</td>
          <td class="paramtype">NT_RpcCallPoller&#160;</td>
          <td class="paramname"><em>poller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a RPC call poller. </p>
<p>This will abort any blocked polling call and prevent additional events from being generated for this poller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>poller handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf3807de6df1143207fd6bfaa3e0ea4b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nt::GetRpcResult </td>
          <td>(</td>
          <td class="paramtype">NT_Entry&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NT_RpcCall&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the result (return value) of a RPC call. </p>
<p>This function blocks until the result is received. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>entry handle of RPC entry </td></tr>
    <tr><td class="paramname">call</td><td>RPC call handle returned by <a class="el" href="group__RpcFunctions.html#gafedd06b812cf26df940820f3e8eb7100" title="Call a RPC function. ">CallRpc()</a> </td></tr>
    <tr><td class="paramname">result</td><td>received result (output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False on error, true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f69ee5f8dadf1cda7daf78ceeac7183"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nt::GetRpcResult </td>
          <td>(</td>
          <td class="paramtype">NT_Entry&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NT_RpcCall&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>timed_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the result (return value) of a RPC call. </p>
<p>This function blocks until the result is received or it times out. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>entry handle of RPC entry </td></tr>
    <tr><td class="paramname">call</td><td>RPC call handle returned by <a class="el" href="group__RpcFunctions.html#gafedd06b812cf26df940820f3e8eb7100" title="Call a RPC function. ">CallRpc()</a> </td></tr>
    <tr><td class="paramname">result</td><td>received result (output) </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout, in seconds </td></tr>
    <tr><td class="paramname">timed_out</td><td>true if the timeout period elapsed (output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False on error or timeout, true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf2b88d0559e728fad3f29768cf461d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NT_RpcCall NT_CallRpc </td>
          <td>(</td>
          <td class="paramtype">NT_Entry&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>params_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a RPC function. </p>
<p>May be used on either the client or server. This function is non-blocking. Either <a class="el" href="group__RpcFunctions.html#gacd97e095d6bb046d67ad8a2f1e9d5fbe" title="Get the result (return value) of a RPC call. ">NT_GetRpcResult()</a> or <a class="el" href="group__RpcFunctions.html#ga13dac0f3caf774a54c727ddb1ad20c9f" title="Ignore the result of a RPC call. ">NT_CancelRpcResult()</a> must be called to either get or ignore the result of the call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>entry handle of RPC entry </td></tr>
    <tr><td class="paramname">params</td><td>parameter </td></tr>
    <tr><td class="paramname">params_len</td><td>length of param in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RPC call handle (for use with <a class="el" href="group__RpcFunctions.html#gacd97e095d6bb046d67ad8a2f1e9d5fbe" title="Get the result (return value) of a RPC call. ">NT_GetRpcResult()</a> or <a class="el" href="group__RpcFunctions.html#ga13dac0f3caf774a54c727ddb1ad20c9f" title="Ignore the result of a RPC call. ">NT_CancelRpcResult()</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="gad1a48a36a7bf37cf3f00ae26bd8dc4ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NT_CancelPollRpc </td>
          <td>(</td>
          <td class="paramtype">NT_RpcCallPoller&#160;</td>
          <td class="paramname"><em>poller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a PollRpc call. </p>
<p>This wakes up a call to PollRpc for this poller and causes it to immediately return an empty array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>poller handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga13dac0f3caf774a54c727ddb1ad20c9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NT_CancelRpcResult </td>
          <td>(</td>
          <td class="paramtype">NT_Entry&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NT_RpcCall&#160;</td>
          <td class="paramname"><em>call</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ignore the result of a RPC call. </p>
<p>This function is non-blocking. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>entry handle of RPC entry </td></tr>
    <tr><td class="paramname">call</td><td>RPC call handle returned by <a class="el" href="group__RpcFunctions.html#gaaf2b88d0559e728fad3f29768cf461d3" title="Call a RPC function. ">NT_CallRpc()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga878ff7a7b432fd6c0b8eee764ee4120a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NT_CreatePolledRpc </td>
          <td>(</td>
          <td class="paramtype">NT_Entry&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>def_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NT_RpcCallPoller&#160;</td>
          <td class="paramname"><em>poller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a polled RPC entry point. </p>
<p>Only valid to use on the server. The caller is responsible for calling <a class="el" href="group__RpcFunctions.html#ga93d69a8cf511f382e37ad80cddd48b00" title="Get the next incoming RPC call. ">NT_PollRpc()</a> or <a class="el" href="group__RpcFunctions.html#ga800437b55c2ebf5b448402420bd2b2c2" title="Get the next incoming RPC call. ">NT_PollRpcTimeout()</a> to poll for servicing incoming RPC calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>entry handle of RPC entry </td></tr>
    <tr><td class="paramname">def</td><td>RPC definition </td></tr>
    <tr><td class="paramname">def_len</td><td>length of def in bytes </td></tr>
    <tr><td class="paramname">poller</td><td>poller handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab91bc59f5a82124864f78d80ab99784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NT_CreateRpc </td>
          <td>(</td>
          <td class="paramtype">NT_Entry&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>def_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RpcFunctions.html#ga5b9ab2c7ec2ecfa65bd8e38a3e2058cc">NT_RpcCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a callback-based RPC entry point. </p>
<p>Only valid to use on the server. The callback function will be called when the RPC is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>entry handle of RPC entry </td></tr>
    <tr><td class="paramname">def</td><td>RPC definition </td></tr>
    <tr><td class="paramname">def_len</td><td>length of def in bytes </td></tr>
    <tr><td class="paramname">data</td><td>data pointer to pass to callback function </td></tr>
    <tr><td class="paramname">callback</td><td>callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf8d942f44d38f62131351d570d80be6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NT_RpcCallPoller NT_CreateRpcCallPoller </td>
          <td>(</td>
          <td class="paramtype">NT_Inst&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a RPC call poller. </p>
<p>Only valid to use on the server. A poller provides a single queue of poll events. Events linked to this poller (using <a class="el" href="group__RpcFunctions.html#ga878ff7a7b432fd6c0b8eee764ee4120a" title="Create a polled RPC entry point. ">NT_CreatePolledRpc()</a>) will be stored in the queue and must be collected by calling <a class="el" href="group__RpcFunctions.html#ga93d69a8cf511f382e37ad80cddd48b00" title="Get the next incoming RPC call. ">NT_PollRpc()</a> or <a class="el" href="group__RpcFunctions.html#ga800437b55c2ebf5b448402420bd2b2c2" title="Get the next incoming RPC call. ">NT_PollRpcTimeout()</a>. The returned handle must be destroyed with <a class="el" href="group__RpcFunctions.html#ga25915112fcb5e7adba02b130629e6093" title="Destroy a RPC call poller. ">NT_DestroyRpcCallPoller()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>instance handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>poller handle </dd></dl>

</div>
</div>
<a class="anchor" id="ga25915112fcb5e7adba02b130629e6093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NT_DestroyRpcCallPoller </td>
          <td>(</td>
          <td class="paramtype">NT_RpcCallPoller&#160;</td>
          <td class="paramname"><em>poller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a RPC call poller. </p>
<p>This will abort any blocked polling call and prevent additional events from being generated for this poller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>poller handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacd97e095d6bb046d67ad8a2f1e9d5fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NT_GetRpcResult </td>
          <td>(</td>
          <td class="paramtype">NT_Entry&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NT_RpcCall&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>result_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the result (return value) of a RPC call. </p>
<p>This function blocks until the result is received. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>entry handle of RPC entry </td></tr>
    <tr><td class="paramname">call</td><td>RPC call handle returned by <a class="el" href="group__RpcFunctions.html#gaaf2b88d0559e728fad3f29768cf461d3" title="Call a RPC function. ">NT_CallRpc()</a> </td></tr>
    <tr><td class="paramname">result_len</td><td>length of returned result in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error, or result. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3aa1b97f51c05de47544b223552ff396"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NT_GetRpcResultTimeout </td>
          <td>(</td>
          <td class="paramtype">NT_Entry&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NT_RpcCall&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>result_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NT_Bool *&#160;</td>
          <td class="paramname"><em>timed_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the result (return value) of a RPC call. </p>
<p>This function blocks until the result is received or it times out. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>entry handle of RPC entry </td></tr>
    <tr><td class="paramname">call</td><td>RPC call handle returned by <a class="el" href="group__RpcFunctions.html#gaaf2b88d0559e728fad3f29768cf461d3" title="Call a RPC function. ">NT_CallRpc()</a> </td></tr>
    <tr><td class="paramname">result_len</td><td>length of returned result in bytes </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout, in seconds </td></tr>
    <tr><td class="paramname">timed_out</td><td>true if the timeout period elapsed (output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error or timeout, or result. </dd></dl>

</div>
</div>
<a class="anchor" id="ga83136a784573ddf15f5966e44ed841b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NT_PackRpcDefinition </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structNT__RpcDefinition.html">NT_RpcDefinition</a> *&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>packed_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack a RPC version 1 definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">def</td><td>RPC version 1 definition </td></tr>
    <tr><td class="paramname">packed_len</td><td>length of return value in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw packed bytes. Use C standard library free() to release. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2fc74beb34e88d91d332c20c8fe27c1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NT_PackRpcValues </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structNT__Value.html">NT_Value</a> **&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>values_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>packed_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack RPC values as required for RPC version 1 definition messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>array of values to pack </td></tr>
    <tr><td class="paramname">values_len</td><td>length of values </td></tr>
    <tr><td class="paramname">packed_len</td><td>length of return value in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw packed bytes. Use C standard library free() to release. </dd></dl>

</div>
</div>
<a class="anchor" id="ga93d69a8cf511f382e37ad80cddd48b00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structNT__RpcAnswer.html">NT_RpcAnswer</a>* NT_PollRpc </td>
          <td>(</td>
          <td class="paramtype">NT_RpcCallPoller&#160;</td>
          <td class="paramname"><em>poller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next incoming RPC call. </p>
<p>This blocks until the next incoming RPC call is received. This is intended to be used with <a class="el" href="group__RpcFunctions.html#ga878ff7a7b432fd6c0b8eee764ee4120a" title="Create a polled RPC entry point. ">NT_CreatePolledRpc()</a>; RPC calls created using <a class="el" href="group__RpcFunctions.html#gaab91bc59f5a82124864f78d80ab99784" title="Create a callback-based RPC entry point. ">NT_CreateRpc()</a> will not be serviced through this function. Upon successful return, <a class="el" href="group__RpcFunctions.html#ga88c011f694f6d95fb12b58851c5352f9" title="Post RPC response (return value) for a polled RPC. ">NT_PostRpcResponse()</a> must be called to send the return value to the caller. The returned array must be freed using <a class="el" href="group__UtilityFunctions.html#ga560d63022a5d123bb7d3739a9ce80403" title="Disposes a Rpc Answer array. ">NT_DisposeRpcAnswerArray()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>poller handle </td></tr>
    <tr><td class="paramname">len</td><td>length of returned array (output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of RPC call information. Only returns NULL if an error occurred (e.g. the instance was invalid or is shutting down). </dd></dl>

</div>
</div>
<a class="anchor" id="ga800437b55c2ebf5b448402420bd2b2c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structNT__RpcAnswer.html">NT_RpcAnswer</a>* NT_PollRpcTimeout </td>
          <td>(</td>
          <td class="paramtype">NT_RpcCallPoller&#160;</td>
          <td class="paramname"><em>poller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NT_Bool *&#160;</td>
          <td class="paramname"><em>timed_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next incoming RPC call. </p>
<p>This blocks until the next incoming RPC call is received or it times out. This is intended to be used with <a class="el" href="group__RpcFunctions.html#ga878ff7a7b432fd6c0b8eee764ee4120a" title="Create a polled RPC entry point. ">NT_CreatePolledRpc()</a>; RPC calls created using <a class="el" href="group__RpcFunctions.html#gaab91bc59f5a82124864f78d80ab99784" title="Create a callback-based RPC entry point. ">NT_CreateRpc()</a> will not be serviced through this function. Upon successful return, <a class="el" href="group__RpcFunctions.html#ga88c011f694f6d95fb12b58851c5352f9" title="Post RPC response (return value) for a polled RPC. ">NT_PostRpcResponse()</a> must be called to send the return value to the caller. The returned array must be freed using <a class="el" href="group__UtilityFunctions.html#ga560d63022a5d123bb7d3739a9ce80403" title="Disposes a Rpc Answer array. ">NT_DisposeRpcAnswerArray()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>poller handle </td></tr>
    <tr><td class="paramname">len</td><td>length of returned array (output) </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout, in seconds </td></tr>
    <tr><td class="paramname">timed_out</td><td>true if the timeout period elapsed (output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of RPC call information. If NULL is returned and timed_out is also false, an error occurred (e.g. the instance was invalid or is shutting down). </dd></dl>

</div>
</div>
<a class="anchor" id="ga88c011f694f6d95fb12b58851c5352f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NT_PostRpcResponse </td>
          <td>(</td>
          <td class="paramtype">NT_Entry&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NT_RpcCall&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>result_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post RPC response (return value) for a polled RPC. </p>
<p>The rpc and call parameters should come from the <a class="el" href="structNT__RpcAnswer.html" title="NetworkTables RPC Call Data. ">NT_RpcAnswer</a> returned by <a class="el" href="group__RpcFunctions.html#ga93d69a8cf511f382e37ad80cddd48b00" title="Get the next incoming RPC call. ">NT_PollRpc()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>entry handle of RPC entry (from <a class="el" href="structNT__RpcAnswer.html" title="NetworkTables RPC Call Data. ">NT_RpcAnswer</a>) </td></tr>
    <tr><td class="paramname">call</td><td>RPC call handle (from <a class="el" href="structNT__RpcAnswer.html" title="NetworkTables RPC Call Data. ">NT_RpcAnswer</a>) </td></tr>
    <tr><td class="paramname">result</td><td>result raw data that will be provided to remote caller </td></tr>
    <tr><td class="paramname">result_len</td><td>length of result in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf32669d9df431ba49db556212f1acea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NT_Bool NT_UnpackRpcDefinition </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>packed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>packed_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structNT__RpcDefinition.html">NT_RpcDefinition</a> *&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpack a RPC version 1 definition. </p>
<p>This can be used for introspection or validation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packed</td><td>raw packed bytes </td></tr>
    <tr><td class="paramname">packed_len</td><td>length of packed in bytes </td></tr>
    <tr><td class="paramname">def</td><td>RPC version 1 definition (output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfully unpacked, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b36d08440744e11de7f7ec810caac25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structNT__Value.html">NT_Value</a>** NT_UnpackRpcValues </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>packed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>packed_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NT_Type *&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>types_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpack RPC values as required for RPC version 1 definition messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packed</td><td>raw packed bytes </td></tr>
    <tr><td class="paramname">packed_len</td><td>length of packed in bytes </td></tr>
    <tr><td class="paramname">types</td><td>array of data types (as provided in the RPC definition) </td></tr>
    <tr><td class="paramname">types_len</td><td>length of types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of <a class="el" href="structNT__Value.html" title="NetworkTables Entry Value. ">NT_Value</a>'s. </dd></dl>

</div>
</div>
<a class="anchor" id="gad6e443f5e1fce0c35d101658e0449f0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NT_Bool NT_WaitForRpcCallQueue </td>
          <td>(</td>
          <td class="paramtype">NT_Inst&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the incoming RPC call queue to be empty. </p>
<p>This is primarily useful for deterministic testing. This blocks until either the RPC call queue is empty (e.g. there are no more events that need to be passed along to callbacks or poll queues) or the timeout expires. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>instance handle </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout, in seconds. Set to 0 for non-blocking behavior, or a negative value to block indefinitely </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if timed out, otherwise true. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4fcd223fd9049b8c7b7ebd65645018f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string nt::PackRpcDefinition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnt_1_1RpcDefinition.html">RpcDefinition</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack a RPC version 1 definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">def</td><td>RPC version 1 definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw packed bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga22a9764da247362ab7978091e33b45c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string nt::PackRpcValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::shared_ptr&lt; <a class="el" href="classnt_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack RPC values as required for RPC version 1 definition messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>array of values to pack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw packed bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ce76c65122975d3f70083079af25d81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; RpcAnswer &gt; nt::PollRpc </td>
          <td>(</td>
          <td class="paramtype">NT_RpcCallPoller&#160;</td>
          <td class="paramname"><em>poller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next incoming RPC call. </p>
<p>This blocks until the next incoming RPC call is received. This is intended to be used with <a class="el" href="group__RpcFunctions.html#gaebf497758cda4198a1e5afed7a43f31a" title="Create a polled RPC entry point. ">CreatePolledRpc()</a>; RPC calls created using <a class="el" href="group__RpcFunctions.html#gab5b4749e63b20f549bb321fde54a96ed" title="Create a callback-based RPC entry point. ">CreateRpc()</a> will not be serviced through this function. Upon successful return, <a class="el" href="group__RpcFunctions.html#ga760a60f2ae5270ef7488419cf0ae8952" title="Post RPC response (return value) for a polled RPC. ">PostRpcResponse()</a> must be called to send the return value to the caller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>poller handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Information on the next RPC calls. Only returns empty if an error occurred (e.g. the instance was invalid or is shutting down). </dd></dl>

</div>
</div>
<a class="anchor" id="ga51a85b610d17ff4d26dec5c7a971b27b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; RpcAnswer &gt; nt::PollRpc </td>
          <td>(</td>
          <td class="paramtype">NT_RpcCallPoller&#160;</td>
          <td class="paramname"><em>poller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>timed_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next incoming RPC call. </p>
<p>This blocks until the next incoming RPC call is received or it times out. This is intended to be used with <a class="el" href="group__RpcFunctions.html#gaebf497758cda4198a1e5afed7a43f31a" title="Create a polled RPC entry point. ">CreatePolledRpc()</a>; RPC calls created using <a class="el" href="group__RpcFunctions.html#gab5b4749e63b20f549bb321fde54a96ed" title="Create a callback-based RPC entry point. ">CreateRpc()</a> will not be serviced through this function. Upon successful return, <a class="el" href="group__RpcFunctions.html#ga760a60f2ae5270ef7488419cf0ae8952" title="Post RPC response (return value) for a polled RPC. ">PostRpcResponse()</a> must be called to send the return value to the caller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>poller handle </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout, in seconds </td></tr>
    <tr><td class="paramname">timed_out</td><td>true if the timeout period elapsed (output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Information on the next RPC calls. If empty and timed_out is also false, an error occurred (e.g. the instance was invalid or is shutting down). </dd></dl>

</div>
</div>
<a class="anchor" id="ga760a60f2ae5270ef7488419cf0ae8952"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nt::PostRpcResponse </td>
          <td>(</td>
          <td class="paramtype">NT_Entry&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NT_RpcCall&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post RPC response (return value) for a polled RPC. </p>
<p>The rpc and call parameters should come from the <a class="el" href="classnt_1_1RpcAnswer.html" title="NetworkTables Remote Procedure Call (Server Side) ">RpcAnswer</a> returned by <a class="el" href="group__RpcFunctions.html#ga0ce76c65122975d3f70083079af25d81" title="Get the next incoming RPC call. ">PollRpc()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>entry handle of RPC entry (from <a class="el" href="classnt_1_1RpcAnswer.html" title="NetworkTables Remote Procedure Call (Server Side) ">RpcAnswer</a>) </td></tr>
    <tr><td class="paramname">call</td><td>RPC call handle (from <a class="el" href="classnt_1_1RpcAnswer.html" title="NetworkTables Remote Procedure Call (Server Side) ">RpcAnswer</a>) </td></tr>
    <tr><td class="paramname">result</td><td>result raw data that will be provided to remote caller </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga13953cf6a3e7992ba93a62fb9164132c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nt::UnpackRpcDefinition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>packed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnt_1_1RpcDefinition.html">RpcDefinition</a> *&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpack a RPC version 1 definition. </p>
<p>This can be used for introspection or validation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packed</td><td>raw packed bytes </td></tr>
    <tr><td class="paramname">def</td><td>RPC version 1 definition (output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfully unpacked, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2da3c02387c3bddcb5876dfa2c9afe34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; Value &gt; &gt; nt::UnpackRpcValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>packed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; NT_Type &gt;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpack RPC values as required for RPC version 1 definition messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packed</td><td>raw packed bytes </td></tr>
    <tr><td class="paramname">types</td><td>array of data types (as provided in the RPC definition) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of values. </dd></dl>

</div>
</div>
<a class="anchor" id="ga03a487ed431a8f56acd11f94ece82bed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nt::NetworkTableInstance::WaitForRpcCallQueue </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for the incoming RPC call queue to be empty. </p>
<p>This is primarily useful for deterministic testing. This blocks until either the RPC call queue is empty (e.g. there are no more events that need to be passed along to callbacks or poll queues) or the timeout expires. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>timeout, in seconds. Set to 0 for non-blocking behavior, or a negative value to block indefinitely </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if timed out, otherwise true. </dd></dl>

</div>
</div>
<a class="anchor" id="ga90bd47445b0424fefca0df54d97ede35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nt::WaitForRpcCallQueue </td>
          <td>(</td>
          <td class="paramtype">NT_Inst&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the incoming RPC call queue to be empty. </p>
<p>This is primarily useful for deterministic testing. This blocks until either the RPC call queue is empty (e.g. there are no more events that need to be passed along to callbacks or poll queues) or the timeout expires. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>instance handle </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout, in seconds. Set to 0 for non-blocking behavior, or a negative value to block indefinitely </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if timed out, otherwise true. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Oct 28 2017 05:22:45 for WPILibC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
